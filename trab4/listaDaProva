Inserir algo que n seja uma peça no tab
Inserir casa nula
dar free em uma casa

1)Correto.Embora a programação modular não utilize nomes como classe,objeto e métodos, podemos fazer uma analogia entre os elementos dela com os da programação orientada a objeto. Imagine a seguinte situação: Temos o módulo peça que possui uma estrutura com o mesmo nome, a qual contém cor e id. Este também possui diversas funções de acesso. Agora, imagine que declaramos 6 ponteiros para peça em um módulo distinto da mesma aplicação. Podemos considerar esses seis ponteiros como sendo instâncias da classe peça(objetos), os campos cor e id como sendo os atributos da classe e as funções de acesso como sendo os métodos da classe. Portanto, sim, de uma certa perspectiva a programação modular pode ser considerada uma programação orientada a objetos
5)Deturpações:

1)Torna ponteiro para lista de adjacencias de algum vértice em nulo

2)Torna ponteiro para lista de adjacencias de algum vértice em Lixo

3)Torna o ponteiro para o vetor de lista de adjacencias em nulo

4)Faz com que o campo quantidade de arestas seja diferente do valor real de arestas

6)GRA_Verificador(GRA_tppGraph g) {
	int i,qtdArestas = 0;
	if(g->vetAdjs == NULL) {
		CNT_Contar(“erro-vetAdjsNulo”);
	}
	for(i=0;i<g->qtdVert;i++) {
		if(g->vetAdjs[i] == NULL) {
			CNT_Contar(“erro-listaDeAdjsNula”);
		}
		if(g->vetAdjs[i] == LIXO) {
			return GRA_tpCondRetErroListaDeAdjsLixo;
		}
		qtdArestas += g->vetAdjs[i]->qtdNos;
	}
	if(qtdArestas != g->qtdArestas) {	
		return GRA_tpCondRetErroQtdArestasErrada;
	}

}

7 incompleta)GRA_Verificador(GRA_tppGraph g) {
	int i,qtdArestas = 0;
	if(g->vetAdjs == NULL) {
		CNT_Contar(“erro-vetAdjsNulo”);
		return GRA_tpCondRetErroVetAdjsNulo;
	}
	for(i=0;i<g->qtdVert;i++) {
		if(g->vetAdjs[i] == NULL) {
			return GRA_tpCondRetErroListaDeAdjsNula;
			CNT_Contar(“erro-listaDeAdjsNula”);
		}
		if(g->vetAdjs[i] == LIXO) {
			CNT_Contar(“erro-listaDeAdjsApontaLixo”);
			return GRA_tpCondRetErroListaDeAdjsLixo;
		}
		qtdArestas += g->vetAdjs[i]->qtdNos;
	}
	if(qtdArestas != g->qtdArestas) {
		CNT_Contar(“erro-listaDeAdjsApontaLixo”);	
		return GRA_tpCondRetErroQtdArestasErrada;
	}

}

8)void loop(int n) {
	int i;
	for(i=0;i<n;i++) {
 	    printf(“%d\n”,i); //trace de evolução
	}

}

9)Utilizando a instrumentação, vários erros que são extrememante dificéis de identificar e que estão fortemente relacionados com violações de assertivas estruturais, tornam-se bem mais fáceis de serem percebidos, pois com a instrumentação sempre estamos verificando se a estrutura instrumentada está de acordo com suas assertivas estruturais.


